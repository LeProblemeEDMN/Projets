#version 330

in vec2 tCoords;
in vec2 ssaoCoords;
in vec3 toCameraVector;
in float visibility;
in vec3 toPointVector[5];
in vec3 worldPos;
in vec3 eyePos;
in vec3 vecFrag;
in mat3 toTangentSpace;
in mat4 invV;
in vec4 shadowCoords;

out vec4 out_Color;

struct Spot {
	vec3 attenuation;
	vec3 lookVec;
	float angle;
	vec3 color;
	sampler2D textSpot;
	float far;
};

uniform Spot[10] spots;

struct PointLight {
	vec3 attenuation;
	vec3 color;
	float far;
};

uniform PointLight[10] points;
uniform sampler2D modelTexture;
uniform sampler2D sunTexture;
uniform sampler2D normalTexture;
uniform sampler2D ssaoTexture;
uniform samplerCube environmentMap;
uniform float reflectivity;
uniform float shineDamper;
uniform samplerCube[10] textCubes;
uniform vec3 skyColor;
uniform vec2 materialValue;


uniform vec3[10] positionSpotWorld;
uniform vec3[10] positionPointWorld;
uniform vec3[10] positionSpot;
uniform mat4[10] spotMatrix;
uniform float[5] pointInUse;
uniform float[5] spotInUse;

uniform vec2 mapSize;

const int pcfCount=3;
const float totalTexels=(pcfCount*2.0+1.0)*(pcfCount*2.0+1.0);

uniform vec3[10] positionPoint;
const float near=0.1;
const float blueMultiplicator=18;
float LinearizeDepth(float depth,float far) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    	
    return (2.0 * near * far) / (far + near - z * (far - near));	
}

vec3 applyFog( in vec3  rgb,      // original color of the pixel
               in float fogAmount, // camera to point distance
               in vec3  rayDir,   // camera to point vector
               in vec3  sunDir )  // sun light direction
{
    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );
    vec3  fogColor  = mix( skyColor, // bluish
                           vec3(1.0,0.9,0.7), // yellowish
                           pow(sunAmount,8.0) );
    return mix( rgb, fogColor, fogAmount );
}
float sunShadow();

void main(void){
	
	vec3 normalMapValue = 2.0 * texture(normalTexture, tCoords).rgb - 1.0;

	vec3 unitNormal = normalize(normalMapValue.rgb);
	vec3 unitCameraVector=normalize(toCameraVector);
	
	vec3 totalDiffuse= vec3(0.0);
	vec3 totalSpecular= vec3(0.0);
	
	vec4 textureColour=texture(modelTexture,tCoords);
	if(textureColour.a<0.5){
		discard;
	}
	//-----------SPOTS------------------------------------------------
    for(int id=0;id<5;id++){
        int i=int(spotInUse[id]);
            if(i>=0){
            vec3 dirVec=spots[i].lookVec;
            vec3 toLightVector=positionSpotWorld[i] -worldPos;
            float d1=length(toLightVector);
            vec3 unitLightVector=normalize(toLightVector);
            float ac=acos(dot(-unitLightVector,dirVec));
            if(ac< spots[i].angle){
                toLightVector= toTangentSpace*(positionSpot[i] -eyePos);
                unitLightVector=normalize(toLightVector);

                float shadowFactor=1;

                vec4 s=spotMatrix[i]*vec4(worldPos,1);
                s.xyz/=s.w;
                s.xyz*=0.5;
                s.xyz+=0.5;
                float tz=texture(spots[i].textSpot,s.xy).r;
                float z=LinearizeDepth(s.z,spots[i].far)/spots[i].far;

                if((z-tz)>0.005){
                    shadowFactor=0.3;
                }

                float distance=length(toLightVector);
                float attenuationFactor=spots[i].attenuation.x+(spots[i].attenuation.y*distance)+(spots[i].attenuation.z*distance*distance);

                float nDot1=dot(unitNormal,unitLightVector);
                float brightness=max(nDot1,0.0);
                vec3 lightDirection=-unitLightVector;
                vec3 reflectedLightDirection=reflect(lightDirection,unitNormal);

                vec3 halfwayDir = normalize(unitLightVector + unitCameraVector);

                float specularFactor=dot(reflectedLightDirection,unitCameraVector);
                specularFactor=dot(unitNormal, halfwayDir);
                specularFactor=max(specularFactor,0.0);
                float dampedFactor=pow(specularFactor,shineDamper);
                totalDiffuse=totalDiffuse+(brightness*spots[i].color)/(attenuationFactor/shadowFactor);
                totalSpecular=totalSpecular+(dampedFactor*reflectivity*spots[i].color)/(attenuationFactor/shadowFactor);
                //out_Color=vec4(totalDiffuse,1);
                }
            }

        }
	
	//-----------POINTS --------------------------------------
	for(int id=0;id<5;id++){
 	int i=int(pointInUse[id]);
 	
	if(i>=0){
	vec3 toLightVector= toTangentSpace*(positionPoint[i] -eyePos); 
    vec3 unitLightVector=normalize(toLightVector);
    
    float shadowFactor=1;
    float distance=length(toLightVector);
    vec3 realPointVec=positionPointWorld[i] -worldPos;
	float z=(length(realPointVec)-0.1)/points[i].far;
	float tz=texture(textCubes[i],normalize(-realPointVec)).r;
	float v=z-tz;
	if(v>0.005){
   		shadowFactor=0.3;
    }
    if(i==0)shadowFactor=sunShadow();
	float attenuationFactor=points[i].attenuation.x+(points[i].attenuation.y*distance)+(points[i].attenuation.z*distance*distance);
	
	float nDot1=dot(unitNormal,unitLightVector);
	float brightness=max(nDot1,0.0);	
	vec3 lightDirection=-unitLightVector;
	vec3 reflectedLightDirection=reflect(lightDirection,unitNormal);

	float specularFactor=dot(reflectedLightDirection,unitCameraVector);
	specularFactor=max(specularFactor,0.0);
	float dampedFactor=pow(specularFactor,shineDamper);
	   vec3 halfwayDir = normalize(unitLightVector + unitCameraVector);
  	 dampedFactor = pow(max(dot(unitNormal, halfwayDir), 0.0), shineDamper);
	totalDiffuse=totalDiffuse+(brightness*points[i].color)/(attenuationFactor/shadowFactor);
	totalSpecular=totalSpecular+(dampedFactor*reflectivity*points[i].color)/(attenuationFactor/shadowFactor);
	    }
	}

	
	//---------------------FIN LUMIERES-----------------------------------
	totalDiffuse=max(totalDiffuse,0.4);	 //totalDiffuse*texture(ssaoTexture,ssaoCoords).r
	
	out_Color =vec4(totalDiffuse,0.0)*textureColour+vec4(totalSpecular,1.0);
	if(length(materialValue)>0){
	    unitNormal.b*=blueMultiplicator;
	    unitNormal=normalize(unitNormal);

		vec4 norm=vec4(inverse(toTangentSpace)*unitNormal,0.0);
	    norm=invV*norm;

		vec4 reflectedColor=texture(environmentMap,reflect(vecFrag,norm.xyz));
		vec4 refractedColor=texture(environmentMap,refract(vecFrag,norm.xyz,1.0/1.33));
		out_Color=mix(out_Color,reflectedColor,materialValue.x);
		out_Color=mix(out_Color,refractedColor,materialValue.y);
	}
	vec3 s=vec3(-0.5,-0.5,0);
	s=normalize(s);
	out_Color.rgb =applyFog(out_Color.rgb,1-visibility,-unitCameraVector,s);

}


float sunShadow(){
	float texelSizeX=1.0/mapSize.x;
	float texelSizeY=1.0/mapSize.y;
	float total=0.0;
	for(int x=-pcfCount;x<=pcfCount;x++){
		for(int y=-pcfCount;y<=pcfCount;y++){
			float objectNearestLight=texture(sunTexture,shadowCoords.xy+vec2(x*texelSizeX,y*texelSizeY)).r;
			if(shadowCoords.z-0.005>objectNearestLight){
				total+=1;
			}
	}
	total/=totalTexels;
	
	}
	 return 1.0-(total*shadowCoords.w)*3.0;

}