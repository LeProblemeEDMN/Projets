#version 330

in vec2 TexCoord;

out vec4 FragColor;

uniform sampler2D gPositionMap;
uniform sampler2D normalMap;
uniform sampler2D noiseTexture;
uniform float gSampleRad;
uniform mat4 gProj;
uniform mat4 viewMatrix;

uniform vec3 samples[16];
uniform mat4 projMatrix;

const vec2 noiseScale = vec2(720/4, 480/4);

const int MAX_KERNEL_SIZE = 128;
uniform vec3 gKernel[MAX_KERNEL_SIZE];

vec3 getCoord(vec2 t){
vec4 clip=vec4(t,texture(gPositionMap, t).x,1);
clip*=2;
clip-=vec4(1);
clip.w=1;
clip=(inverse(gProj)*clip);
   return (clip.xyz/clip.w) ;
}


void main()
{
	int kernelSize = 16;
   float radius = 1;   
vec2 passTextureCoords=TexCoord;
   vec3 fragPos = texture(gPositionMap, passTextureCoords).xyz*100;
   fragPos.z=-fragPos.z;
   vec3 normal = texture(normalMap, passTextureCoords).xyz;
   vec3 randomVec = texture(noiseTexture, passTextureCoords ).xyz;
   
   normal = normalize(normal);
   vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
   vec3 bitangent = normalize(cross(normal, tangent));
   mat3 TBN = mat3(tangent, bitangent, normal);
   
   float occlusion = 0;
   for(int i = 0; i < kernelSize; i++){
      vec3 samp = TBN * samples[i];
      samp = fragPos + samp * radius;
      
      vec4 offset = vec4(samp, 1);
      offset = projMatrix * offset;
      offset.xyz /= offset.w;
      offset.xyz = offset.xyz * 0.5 + 0.5;
      
      float sampleDepth = -texture(gPositionMap, offset.xy).z*100;
      float rangeCheck = smoothstep(0, 1, radius / abs(fragPos.z - sampleDepth));      
      occlusion += (sampleDepth >= samp.z ? 1 : 0) * rangeCheck;
   }
   
   occlusion = 1 - (occlusion/16);
   FragColor = vec4(vec3(pow(occlusion, 8)), 1);
} 